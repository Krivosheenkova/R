# assigning variables 
variable.1 <- "Hello, world!"
assign("variable.2", 1L)

# get full list of assigned variables
print(objects())

# remove objects in current workspace
rm(variable.1, variable.2)


# generating regular sequences
sequence.fwd <- 1:5
sequence.bckw <- 5:1 

cat("1:5\t", sequence.fwd, '\n', "5:1\t", sequence.bckw)

# more general facility for generating sequences is seq():
seq.1 <- seq(from=-1, to=1, along.with=sequence.fwd) # also there is length.out param
cat("seq():": seq.1)

# a related function is rep() which can be used for replicating an object
#   in various complicated ways
rep.1 <- rep(seq(0, 3), times=3, each=2, length.out=10)
cat("rep():", rep.1)

# Create logical vector 
### Logical vectors are generated by conditions.
assign("x", -4:4)
temp <- x < 1
cat("logical vector:", temp)
cat("num of objs which are less than 1: ", sum(temp))

# Missing values detecting
z <- c(1:3, NA, NaN)
z_isna_sum <- sum(is.na(z)); z_isnan_sum <- sum(is.nan(z))
cat("z:"
    , z
    , "\nBoth NA and NaNs sum ="
    , z_isna_sum
    , "\nOnly NaNs sum ="
    , z_isnan_sum)

# Create character vectors
### they may be concatenated into a vector by the c() func; and also
### there is paste() function takes an arbitrary number of arguments 
### and concatenates them one by one into character strings.
vars <- paste(c("var"), 1:10, sep="_")
cat("paste():", vars)
cat("Class:", class(vars))

# Create index vectors; selecting and modifying subsets
### such index vectors can be any of four distinct types:
### 1. Logical vectors;
### 2. A vector of positive integral quantities;
### 3. A vector of negative integral quantities;
### 4. A vector of character strings.

not.na.select <- z[!is.na(z)]
expr.1 <- (z+1)[ (!is.na(z)) & z>0 ]

cat("z:", z, 
    "\nApplying logical vectors:",
    "\nWhere element is not NA:", not.na.select, 
    "\nAdd 1 to each elem of combination and select where is not NA and is positive",
    expr.1)

positive.select <- z[1:2] # reversed select available: z[2:1] -->> output: [1] 2 1 
expr.2 <- c("x", "y")[rep(c(1, 1, 2), times=2)] 

cat("z:", z, 
    "\nApplying positive quantities vectors:",
    "\nElements from 1st to 10th:", positive.select, 
    "\nCreate repeating combination with index vector:",
    expr.2)

negative.select <- z[-(1:2)]
cat("z:", z, 
    "\nApplying negative quantities vectors:",
    "\nSelect elements which are not in (1, 2):", negative.select 
    )

weights.1 <- c(130, 176, 287, 199)
names(weights.1) <- c("orange", "banana", "apple", "peach")
apples <- weights.1[c("apple")]
cat("R makes it possible to name combinations:", weights.1,
    "\nSelect only apples weight:", apples)

# With indexed expression it is possible to perform assignment operation
# only on certain elements of the vector.
z[is.na(z)] <- 0    # replace missing values in z by zeros
z[z < 0] <- -z[z < 0]    # has the same effect as y <- abs(y)


## The entities R operates on are technically known as objects.
# Vectors of numeric (real) or complex values, vectors of logical values and 
# vectors of character strings. These are known as "atomic" structures since 
# their components are all the same type, or mode, namely numeric, complex, 
# logical, character and raw.
# Vectors must have their values all of the same mode.
# R also operates on objects called lists, which are of mode list;
# these are ordered sequences of objects which individually can be of any mode.
# lists are known as “recursive” rather than atomic structures 
## since their components can themselves be lists in their own right.

# mode and length are the intrinsic attributes of R-objects.
# Further properties of an object are usually provided by attributes(object)

# digits to character:
digits.string <- as.character(z)
# further coercion to numerical vector again:
digits.num <- as.integer(digits.string)
cat("z:", z,
    "\nas.character():", digits.string, "\ttype:", typeof(digits.string),
    "\nas.integer():", digits.num, "\ttype:", typeof(digits.num))

# Changing the length of an object:
# once an object of any size has been created, new components may be added
# to it simply by giving it an index value outside its previous range:
print("Add 2 new values to the end of the sequence(NA and 18):")
z[length(z) + 2] <- 18
print(z)
# Another way to change length of vector:
print("Add another 2 values to the end of the sequence (NA and NA):")
length(z) <- 8
print(z)



