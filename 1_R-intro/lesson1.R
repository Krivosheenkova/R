# assigning variables 
variable.1 <- "Hello, world!"
assign("variable.2", 1L)

# get full list of assigned variables
print(objects())

# remove objects in current workspace
rm(variable.1, variable.2)


# generating regular sequences
sequence.fwd <- 1:5
sequence.bckw <- 5:1 

cat("1:5\t", sequence.fwd, '\n', "5:1\t", sequence.bckw)

# more general facility for generating sequences is seq():
seq.1 <- seq(from=-1, to=1, along.with=sequence.fwd) # also there is length.out param
cat("seq():": seq.1)

# a related function is rep() which can be used for replicating an object
#   in various complicated ways
rep.1 <- rep(seq(0, 3), times=3, each=2, length.out=10)
cat("rep():", rep.1)

# Create logical vector 
### Logical vectors are generated by conditions.
assign("x", -4:4)
temp <- x < 1
cat("logical vector:", temp)
cat("num of objs which are less than 1: ", sum(temp))

# Missing values detecting
z <- c(1:3, NA, NaN)
z_isna_sum <- sum(is.na(z)); z_isnan_sum <- sum(is.nan(z))
cat("z:"
    , z
    , "\nBoth NA and NaNs sum ="
    , z_isna_sum
    , "\nOnly NaNs sum ="
    , z_isnan_sum)

# Create character vectors
### they may be concatenated into a vector by the c() func; and also
### there is paste() function takes an arbitrary number of arguments 
### and concatenates them one by one into character strings.
vars <- paste(c("var"), 1:10, sep="_")
cat("paste():", vars)
cat("Class:", class(vars))

# Create index vectors; selecting and modifying subsets
### such index vectors can be any of four distinct types:
### 1. Logical vectors;
### 2. A vector of positive integral quantities;
### 3. A vector of negative integral quantities;
### 4. A vector of character strings.

not.na.select <- z[!is.na(z)]
expr.1 <- (z+1)[ (!is.na(z)) & z>0 ]

cat("z:", z, 
    "\nApplying logical vectors:",
    "\nWhere element is not NA:", not.na.select, 
    "\nAdd 1 to each elem of combination and select where is not NA and is positive",
    expr.1)

positive.select <- z[1:2] # reversed select available: z[2:1] -->> output: [1] 2 1 
expr.2 <- c("x", "y")[rep(c(1, 1, 2), times=2)] 

cat("z:", z, 
    "\nApplying positive quantities vectors:",
    "\nElements from 1st to 10th:", positive.select, 
    "\nCreate repeating combination with index vector:",
    expr.2)

negative.select <- z[-(1:2)]
cat("z:", z, 
    "\nApplying negative quantities vectors:",
    "\nSelect elements which are not in (1, 2):", negative.select 
    )

weights.1 <- c(130, 176, 287, 199)
names(weights.1) <- c("orange", "banana", "apple", "peach")
apples <- weights.1[c("apple")]
cat("R makes it possible to name combinations:", weights.1,
    "\nSelect only apples weight:", apples)

# With indexed expression it is possible to perform assignment operation
# only on certain elements of the vector.
z[is.na(z)] <- 0    # replace missing values in z by zeros
z[z < 0] <- -z[z < 0]    # has the same effect as y <- abs(y)


## The entities R operates on are technically known as objects.
# Vectors of numeric (real) or complex values, vectors of logical values and 
# vectors of character strings. These are known as "atomic" structures since 
# their components are all the same type, or mode, namely numeric, complex, 
# logical, character and raw.
# Vectors must have their values all of the same mode.
# R also operates on objects called lists, which are of mode list;
# these are ordered sequences of objects which individually can be of any mode.
# lists are known as “recursive” rather than atomic structures 
## since their components can themselves be lists in their own right.

# mode and length are the intrinsic attributes of R-objects.
# Further properties of an object are usually provided by attributes(object)

# digits to character:
digits.string <- as.character(z)
# further coercion to numerical vector again:
digits.num <- as.integer(digits.string)
cat("z:", z,
    "\nas.character():", digits.string, "\ttype:", typeof(digits.string),
    "\nas.integer():", digits.num, "\ttype:", typeof(digits.num))

# Changing the length of an object:
# once an object of any size has been created, new components may be added
# to it simply by giving it an index value outside its previous range:
print("Add 2 new values to the end of the sequence(NA and 18):")
z[length(z) + 2] <- 18
print(z)
# Another way to change length of vector:
print("Add another 2 values to the end of the sequence (NA and NA):")
length(z) <- 8
print(z)

# All objects in R have a class, reported by the function class.
# For simple vectors this is just the mode ("numeric", "logical", "character" or "list")
# but "matrix", "array", "factor" and "data.frame" are other possible values.
# A currently complete list of class methods can be got using methods() func.
cat("Complete list of data.frame methods:",
     methods(class="data.frame"))

# Creating ordered and unordered factors
### A factor is a vector object used to specify a discrete classification (grouping)
### of the components of other vectors of the same length

# select categorical feature from iris dataset and get the factor
library(iris)
species <- iris$Species
species.factor <- factor(species) # returns species vector and its distinct vals
species.ord <- ordered(species) # it will be alphabetical order as in prev example
### factor() can use optional params: levels, labels, ordered, exclude 
cat("iris$Species unordered factor levels:", 
    levels(species.factor))


# Calculate the sample mean Sepal.Length for each of species
# using tapply() func (which is used for applying functions)
sepal.length.mean <- tapply(iris$Sepal.Length, species.factor, mean)
sepal.width.mean <- tapply(iris$Sepal.Width, species.factor, mean)
cat("Sepal.Length mean by Species:\n\t")
print(sepal.length.mean)
cat("Sepal.Width mean by Species:\n\t")
print(sepal.width.mean)

# Calculate the sample standard deviation with userfunc
std <- function(x) sqrt(sum((x - mean(x))^2) / (length(x) - 1)) # built-in func: sd()
cat("Standard Deviation of Petal Length =", std(iris$Petal.Length))

# Calculate the confidence interval
ci <- function(x, coef) {
  n <- length(x)
  m <- mean(x)
  stddev <- std(x)
  margin <- qt(coef, df=n-1)*stddev / sqrt(n)
  
  low <- m - margin
  high <- m + margin
  
  outdata <- data.frame(n=n, 
                        mean=m, 
                        sd=round(stddev, digits=3),
                        lower=round(low, digits=3), 
                        upper=round(high, digits=3))
  return(outdata)
}

ci(iris$Petal.Length, 0.95)

